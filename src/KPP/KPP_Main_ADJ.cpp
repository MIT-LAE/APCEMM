/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                                                                  */
/* Main Program File                                                */
/*                                                                  */
/* Generated by KPP-2.2.3 symbolic chemistry Kinetics PreProcessor  */
/*       (http://www.cs.vt.edu/~asandu/Software/KPP)                */
/* KPP is distributed under GPL, the general public licence         */
/*       (http://www.gnu.org/copyleft/gpl.html)                     */
/* (C) 1995-1997, V. Damian & A. Sandu, CGRER, Univ. Iowa           */
/* (C) 1997-2005, A. Sandu, Michigan Tech, Virginia Tech            */
/*     With important contributions from:                           */
/*        M. Damian, Villanova University, USA                      */
/*        R. Sander, Max-Planck Institute for Chemistry, Mainz, Germany */
/*                                                                  */
/* File                 : KPP_Main.c                                */
/* Time                 : Fri Jul 13 11:26:33 2018                  */
/* Equation file        : KPP.kpp                                   */
/* Output root filename : KPP                                       */
/*                                                                  */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <stdbool.h>

#include "KPP/KPP.hpp"
#include "KPP/KPP_Parameters.h"
#include "KPP/KPP_Global.h"
#include "KPP/KPP_Sparse.h"

#define MAX(a, b) \
    ({ __typeof__ (a) _a = (a); \
        __typeof__ (b) _b = (b); \
      _a > _b ? _a : _b; })
#define ABS(x) __extension__ ({ __typeof(x) tmp = x; \
                    tmp < 0 ? -tmp : tmp; })

#define TOPPM     1.00E+06
#define TOPPB     1.00E+09
#define TOPPT     1.00E+12

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                                                                   */
/* MAIN_ADJ - Main program - driver routine                          */
/*   Arguments :                                                     */
/*                                                                   */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Driver for the Adjoint (ADJ) model
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

int INTEGRATE_ADJ( int NADJ, double Y[], double Lambda[][NVAR],
		    double TIN, double TOUT, double ATOL_adj[][NVAR],
		    double RTOL_adj[][NVAR], int ICNTRL_U[],
		    double RCNTRL_U[], int ISTATUS_U[],
		    double RSTATUS_U[] );
void Update_RCONST( const double TEMP, const double PRESS,  \
                    const double AIRDENS, double H2O );

int KPP_Main_ADJ( const double finalPlume[], const double initBackg[],  \
                  const double temperature_K, const double pressure_Pa, \
                  const double airDens, const double timeArray[],       \
                  const unsigned int NT,                                \
                  const double RTOLS, const double ATOLS,               \
                  double VAR_OUTPUT[], const bool verbose )
{

    int i, j;
    int IERR = 1;
    /* Species considered for the optimization */
    int ind_OPT[NOPT] = {ind_NO, ind_NO2, ind_O3};

    /* ---- TIME VARIABLES ------------------ */


    TSTART = timeArray[0];
    TEND   = timeArray[NT-1];

    /* ---- INITIALIZE ARRAYS --------------- */
   
    double VAR_BACKG[NVAR];
    double VAR_RUN[NVAR];

    for ( i = 0; i < NVAR; i++ )
        VAR_BACKG[i] = initBackg[i];

    for ( i = 0; i < NFIX; i++ )
        FIX[i] = initBackg[NVAR + i];

    /* ---- INITIALIZE SENSITIVITIES -------- */

    /* NADJ = Number of functionals for which
     * sensitivities are computed.
     * Note: the setting below is for sensitivities
     * of all final concentrations. The setting may
     * have to be changed for other applications. */
    const int NADJ = NVAR;
    double Y_adj[NADJ][NVAR], ATOL_adj[NADJ][NVAR], RTOL_adj[NADJ][NVAR];


    for( i = 0; i < NADJ; i++ ) {
        for( j = 0; j < NVAR; j++ )
            Y_adj[i][j] = (double)0.0;
    }
    for( j = 0; j < NADJ; j++ )
        Y_adj[j][j] = (double)1.0;

    /* ---- TOLERANCES ---------------------- */

    for( i = 0; i < NVAR; i++ ) {
        RTOL[i] = RTOLS; //1.0e-5; //1.0e-4; 3
        ATOL[i] = ATOLS; //1.0e-4; //1.0e-3; 2
    }
    
    STEPMIN = (double)0.0;
    STEPMAX = (double)0.0;

    /* Tolerances for calculating adjoints are 
     * used for controlling adjoint truncation 
     * error and for solving the linear adjoint
     * equations by iterations.
     * Note: Adjoints typically span many orders
     * of magnitude and a careful tuning of 
     * ATOL_adj may be necessary */

    for( i = 0; i < NADJ; i++ ) {
        for( j = 0; j < NVAR; j++ ) {
            RTOL_adj[i][j] = 1.0e-5;
            ATOL_adj[i][j] = 1.0e-10;
        }
    }

    /* ---- INTEGRATION SETTINGS/STATIS ----- */
    
    /* ICNTRL , RCNTRL  = Adjoint settings
     * ISTATUS, RSTATUS = Adjoint statistics */

    double RCNTRL[20], RSTATUS[20];
    int ICNTRL[20], ISTATUS[20];

    /* Default control options */
    for( i = 0; i < 20; i++ ) {
        ICNTRL[i] = 0;
        RCNTRL[i] = (double)0.0;
        ISTATUS[i] = 0;
        RSTATUS[i] = (double)0.0;
    }

    /*    ADJOINT INPUT PARAMETERS:

    Note: For input parameters equal to zero the default values of the
       corresponding variables are used.

    ICNTRL[0]   = 1: F = F(y)   Independent of T (AUTONOMOUS)
                = 0: F = F(t,y) Depends on T (NON-AUTONOMOUS)

    ICNTRL[1]   = 0: AbsTol, RelTol are NVAR-dimensional vectors
                = 1:  AbsTol, RelTol are scalars

    ICNTRL[2]  -> selection of a particular Rosenbrock method
        = 0 :  default method is Rodas3
        = 1 :  method is  Ros2
        = 2 :  method is  Ros3
        = 3 :  method is  Ros4
        = 4 :  method is  Rodas3
        = 5:   method is  Rodas4

    ICNTRL[3]  -> maximum number of integration steps
        For ICNTRL[4]=0) the default value of BUFSIZE is used

    ICNTRL[5]  -> selection of a particular Rosenbrock method for the
                continuous adjoint integration - for cts adjoint it
                can be different than the forward method ICNTRL(3)
         Note 1: to avoid interpolation errors (which can be huge!)
                   it is recommended to use only ICNTRL[6] = 2 or 4
         Note 2: the performance of the full continuous adjoint
                   strongly depends on the forward solution accuracy Abs/RelTol

    ICNTRL[6] -> Type of adjoint algorithm
         = 0 : default is discrete adjoint ( of method ICNTRL[3] )
         = 1 : no adjoint
         = 2 : discrete adjoint ( of method ICNTRL[3] )
         = 3 : fully adaptive continuous adjoint ( with method ICNTRL[6] )
         = 4 : simplified continuous adjoint ( with method ICNTRL[6] )

    ICNTRL[7]  -> checkpointing the LU factorization at each step:
        ICNTRL[7]=0 : do *not* save LU factorization (the default)
        ICNTRL[7]=1 : save LU factorization
        Note: if ICNTRL[7]=1 the LU factorization is *not* saved

    ~~~>  Real input parameters:

    RCNTRL[0]  -> Hmin, lower bound for the integration step size
          It is strongly recommended to keep Hmin = ZERO

    RCNTRL[1]  -> Hmax, upper bound for the integration step size

    RCNTRL[2]  -> Hstart, starting value for the integration step size

    RCNTRL[3]  -> FacMin, lower bound on step decrease factor (default=0.2)

    RCNTRL[4]  -> FacMax, upper bound on step increase factor (default=6)

    RCNTRL[5]  -> FacRej, step decrease factor after multiple rejections
            (default=0.1)

    RCNTRL[6]  -> FacSafe, by which the new step is slightly smaller
         than the predicted value  (default=0.9)

    RCNTRL[7]  -> ThetaMin. If Newton convergence rate smaller
                  than ThetaMin the Jacobian is not recomputed;
                  (default=0.001) */

    /*    ADJOINT OUTPUT PARAMETERS:

    Note: each call to RosenbrockADJ adds the corrent no. of fcn calls
      to previous value of ISTATUS(1), and similar for the other params.
      Set ISTATUS[0:9] = 0 before call to avoid this accumulation.

    ISTATUS[0] = No. of function calls
    ISTATUS[1] = No. of jacobian calls
    ISTATUS[2] = No. of steps
    ISTATUS[3] = No. of accepted steps
    ISTATUS[4] = No. of rejected steps (except at the beginning)
    ISTATUS[5] = No. of LU decompositions
    ISTATUS[6] = No. of forward/backward substitutions
    ISTATUS[7] = No. of singular matrix decompositions

    ~~~>  Real output parameters:

    RSTATUS[0]  -> Texit, the time corresponding to the
                   computed Y upon return
    RSTATUS[1]  -> Hexit, last accepted step before exit
    For multiple restarts, use Hexit as Hstart in the following run */
    
    /* Running the discrete adjoint */
    ICNTRL[6] = 2;
    
    /* ---- INITIALIZE ARRAYS FOR CURR. RUN - */

    for ( i = 0; i < NVAR; i++ )
        VAR_RUN[i] = VAR_BACKG[i];
                
    for ( i = 0; i < NREACT; i++ )
        RCONST[i] = 0.0E+00;

    for ( i = 0; i < NSPEC; i++ ) {
        HET[i][0] = 0.0E+00;
        HET[i][1] = 0.0E+00;
        HET[i][2] = 0.0E+00;
    }

    Update_RCONST( temperature_K, pressure_Pa, airDens, VAR_RUN[ind_H2O] );

    /* ---- COMPUTE SENSITIVITIES ----------- */

    TIME = TSTART;
    IERR = INTEGRATE_ADJ( NADJ, VAR_RUN, Y_adj, TSTART, TEND, ATOL_adj, RTOL_adj, ICNTRL,
                          RCNTRL, ISTATUS, RSTATUS );

    /* If integration failed, stop here */
    if ( IERR < 0 ) {
        return IERR;
    }

    /* Compute difference between forward ambient
     * run and final plume concentrations */
//    const double DELTAO3  = VAR_RUN[ind_O3]  - finalPlume[ind_O3];
//    const double DELTANO  = VAR_RUN[ind_NO]  - finalPlume[ind_NO];
//    const double DELTANO2 = VAR_RUN[ind_NO2] - finalPlume[ind_NO2];
    
//    for ( i = 0; i < NVAR; i++ )
//        VAR_RUN[i] = VAR_BACKG[i];
//
//  //  VAR_RUN[ind_O3] -= Y_adj[ind_O3][ind_O3]*DELTAO3\
//  //                   + Y_adj[ind_O3][ind_NO]*DELTANO\
//  //                   + Y_adj[ind_O3][ind_NO2]*DELTANO2;
//
//    for( i = 0; i < NADJ; i++ ) {
//        for( j = 0; j < NVAR; j++ )
//            Y_adj[i][j] = (double)0.0;
//    }
//    for( j = 0; j < NADJ; j++ )
//        Y_adj[j][j] = (double)1.0;
//
//    ICNTRL[6] = 2;
//    for ( i = 0; i < NREACT; i++ )
//        RCONST[i] = 0.0E+00;
//
//    for ( i = 0; i < NSPEC; i++ ) {
//        HET[i][0] = 0.0E+00;
//        HET[i][1] = 0.0E+00;
//        HET[i][2] = 0.0E+00;
//    }
//
//    Update_RCONST( temperature_K, pressure_Pa, airDens, VAR_RUN[ind_H2O] );
//
//    IERR = INTEGRATE_ADJ( NADJ, VAR_RUN, Y_adj, T1, T2, ATOL_adj, RTOL_adj, ICNTRL,
//                          RCNTRL, ISTATUS, RSTATUS );
//
//    if ( IERR < 0 ) {
//        return IERR;
//    }

//    printf("\nNOx: %e [ppt]\n",(VAR_RUN[ind_NO]+VAR_RUN[ind_NO2])/airDens*1E12);
//    printf("NO: %e [ppt]\n",(VAR_RUN[ind_NO])/airDens*1E12);
//    printf("NO2: %e [ppt]\n",(VAR_RUN[ind_NO2])/airDens*1E12);
//    printf("O3: %e [ppb]\n",(VAR_RUN[ind_O3])/airDens*1E9);

    /* Optimization method:
     * (1) Conjugate gradient */

    static const char switchOpt[] = "Conjugate Gradient";

    if ( verbose )
        printf("Running KPP adjoint to compute sensitivities and effective emission indices using %s.\n", switchOpt);

    if (( strcmp( switchOpt, "CG" ) == 0 ) || \
        ( strcmp( switchOpt, "Conjugate Gradient" ) == 0 ) ) {

        /* Optimization problem:
         *
         * Let K : R^NVAR -> R^NVAR
         *         x0     -> x(t_f)
         * where x(t_f) is the solution array of 
         *   | dy/dt  = F(t,y)
         *   | y(t_0) = x0
         * evaluated at t = t_f.
         *
         * The goal is to find x0* such that:
         *
         *      x0* = arg min 1/2*( K(x0) - x* )^T * W * ( K(x0) - x* )
         *          = arg min f(x0)
         *
         * where x* is given by the forward plume model. 
         * W is a diagonal matrix containing weights
         *
         * We use the following algorithm:
         *
         * (1) Initialize x0
         * (2) Compute the sensitivity matrix S = (dy_i(t_f)/dy_j(t_0)) 
         *     using KPP_Adjoint. Set the reduced sensitivity matrix
         *     J to S(ind_SPC(1:NOPT),ind_SPC(1:NOPT)).
         * (3) Compute the new direction d = - J^T * W * ( K(x0) - x* )
         * (4) Solve the optimization problem:
         *     alpha* = arg min f( x0 + alpha * d )
         * (5) Update x0 += alpha* * d
         * (6) If f(x0) >= THRESH, return to (2), otherwise break;
         *
         */

        const int N_MAX = 10;
        int N = 0;

        double *wDiff, *dir, *dirold;
        wDiff  = (double *) malloc( sizeof(double) * NOPT );
        if ( wDiff == NULL ) {
            printf("malloc of size %d failed!\n", NOPT);
            return -1;
        }
        dir    = (double *) malloc( sizeof(double) * NOPT );
        if ( dir == NULL ) {
            printf("malloc of size %d failed!\n", NOPT);
            return -1;
        }
        dirold = (double *) malloc( sizeof(double) * NOPT );
        if ( dirold == NULL ) {
            printf("malloc of size %d failed!\n", NOPT);
            return -1;
        }

        double **A_mat; 
        A_mat = (double **) malloc( sizeof(double *) * NOPT );
        for ( i = 0; i < NOPT; i++ ) {
            A_mat[i] = (double *) malloc( sizeof(double) * NOPT );
            if ( A_mat[i] == NULL ) {
                printf("malloc of size %d failed!\n", NOPT);
                return -1;
            }
        }
        
        for ( i = 0; i < NOPT; i++ ) {
            wDiff[i]  = 0.0E+00; 
            dir[i]    = 0.0E+00;
            dirold[i] = 0.0E+00;
            for ( j = 0; j < NOPT; j++ )
                A_mat[i][j] = 0.0E+00;
        }

        /* This needs to be removed eventually */
        double WEIGHTS[NVAR];
        for ( i = 0; i < NVAR; i++ ) {
            if ( i == ind_O3 ) {
                WEIGHTS[i] = 1.0E+01;//1.0E+00;//5.0E01;
            }
            else if ( i == ind_NO || i == ind_NO2 ) {
                WEIGHTS[i] = 1.0;//5.0E+02;//5.0E02;
            }
            else {
                WEIGHTS[i] = 1.0E-02;//1.0E-02;//1.0E-02;
            }
        }

        double normWEIGHTS = 0;
        for ( i = 0; i < NOPT; i++ )
            normWEIGHTS += WEIGHTS[ind_OPT[i]];

        for ( i = 0; i < NOPT; i++ )
            WEIGHTS[ind_OPT[i]] /= normWEIGHTS;


        /* Compute weights */
        double DIAG[NOPT];
        /* Assigning arrays */
        for ( i = 0; i < NOPT; i++ ) {
            for ( j = 0; j < NOPT; j++ ) {
                /* Assign the reduced sensitivity matrix: J^T */
                A_mat[i][j] = (double)Y_adj[ind_OPT[j]][ind_OPT[i]];
            }
            if ( i <= 1 ) // NOx
                DIAG[i] = 1.0 / (VAR_BACKG[ind_OPT[0]] + VAR_BACKG[ind_OPT[1]]);
            else if ( i > 1 ) // O3
                DIAG[i] = 1.0 / (VAR_BACKG[ind_OPT[i]]); 

            wDiff[i] = WEIGHTS[ind_OPT[i]] * DIAG[i] * \
                       ( VAR_RUN[ind_OPT[i]] - finalPlume[ind_OPT[i]] );
        }

        /* Print reduced sensitivity matrix and weighted difference
         * to console? */
        if ( verbose ) {
            printf(" Reduced sensitivity matrix\n");
            printf(" J^T = [");
            for ( i = 0; i < NOPT; i++ ) {
                if ( i > 0 )
                    printf("      \[");
                for ( j = 0; j < NOPT; j++ )
                    printf("%.3e ",A_mat[i][j]);
                printf("]\n");
            }
            printf(" Weighted difference\n");
            printf(" wDiff = [");
            for ( i = 0; i < NOPT; i++ )
                printf("%.3e ",wDiff[i]);
            printf("]\n");
        }

        /* Compute the new direction */
        for ( i = 0; i < NOPT; i++ ) {
            dir[i] = 0.0E+00;
            for ( j = 0; j < NOPT; j++ )
                dir[i] -= A_mat[i][j] * wDiff[j];
        }

        double VAR_MOD[NVAR];
        double VAR_INIT[NVAR];
        double METRIC = 0.0;
        double METRIC_i[NOPT-1];
        double METRIC_min = 1E40;
        double METRIC_ABS_MIN = METRIC_min; 
        double VAR_OPT[NVAR];

        double alpha[NOPT] = { 0.0 };
        double alpha_maxstep = -1.0;
        double alpha_step;

        double VAR_DIR[NVAR];

        double beta = 1.0;

        for ( i = 0; i < NVAR; i++ ) {
            VAR_MOD[i]  = VAR_BACKG[i];
            VAR_INIT[i] = VAR_BACKG[i];
            VAR_DIR[i]  = VAR_BACKG[i];
            VAR_OPT[i]  = VAR_BACKG[i];
        }

        for ( i = 0; i < NOPT; i++ ) {
            if ( VAR_RUN[i]/dir[i] < 0 )
                alpha[i] = -(VAR_RUN[ind_OPT[i]] * DIAG[i]) / dir[i];
            else
                alpha[i] =  (VAR_RUN[ind_OPT[i]] * DIAG[i]) / dir[i];
            if ( alpha_maxstep < 0.0 && alpha[i] > 0.0 )
                alpha_maxstep = alpha[i];
            if ( alpha_maxstep > alpha[i] )
                alpha_maxstep = alpha[i];
        }

        int imin = 0;
        const int nSTEP = 30;
        double STEPARRAY[nSTEP];
        STEPARRAY[0] = 0.125;//1.00;
        for ( i = 1; i < nSTEP/2; i++ )
            STEPARRAY[i] = 2.0*STEPARRAY[i-1];
        for ( i = nSTEP/2; i < nSTEP; i++ )
            STEPARRAY[i] = -STEPARRAY[i-nSTEP/2];

        /* ---- OPTIMIZATION STARTS HERE -------------------- */

        while ( N < N_MAX ) {

            if ( verbose )
                printf("\nN: %d, METRIC: %6.5e\n\n", N, METRIC);

            METRIC_min = 1E40;

            /* ---- LINE SEARCH BEGINS HERE --------- */
            
            ICNTRL[6] = 1; // No adjoint evaluation

            for ( j = 0; j < nSTEP; j++ ) {

                alpha_step = alpha_maxstep/STEPARRAY[j];

                for ( i = 0; i < NVAR; i++ )
                    VAR_MOD[i] = VAR_DIR[i];
                for ( i = 0; i < NOPT; i++ ) {
                    VAR_MOD[ind_OPT[i]] = VAR_DIR[ind_OPT[i]] + alpha_step * dir[i] / DIAG[i];
                    VAR_INIT[ind_OPT[i]] = VAR_MOD[ind_OPT[i]];
                }

                /* Ensure that NOy is conserved */
                VAR_MOD[ind_HNO3] -= alpha_step * ( dir[0] / DIAG[0] + dir[1] / DIAG[1] );
                VAR_INIT[ind_HNO3] = VAR_MOD[ind_HNO3];
    
                for ( i = 0; i < NREACT; i++ )
                    RCONST[i] = 0.0E+00;

                for ( i = 0; i < NSPEC; i++ ) {
                    HET[i][0] = 0.0E+00;
                    HET[i][1] = 0.0E+00;
                    HET[i][2] = 0.0E+00;
                }

                Update_RCONST( temperature_K, pressure_Pa, airDens, VAR_MOD[ind_H2O] );
    
                TIME = TSTART;
                IERR = INTEGRATE_ADJ( NADJ, VAR_MOD, Y_adj, TSTART, TEND, ATOL_adj, RTOL_adj, ICNTRL, RCNTRL, ISTATUS, RSTATUS );
                
                /* Compute metric */
                METRIC = 0.0;
                for ( i = 0; i < NOPT - 1; i++ ) {
                    if ( i < 1 )
                        METRIC += pow( ( WEIGHTS[ind_OPT[0]] * DIAG[0] * ( VAR_MOD[ind_OPT[0]] + VAR_MOD[ind_OPT[1]] - finalPlume[ind_OPT[0]] - finalPlume[ind_OPT[1]] ) ), 2);
                    else
                        METRIC += pow( ( WEIGHTS[ind_OPT[i+1]] * DIAG[i+1] * ( VAR_MOD[ind_OPT[i+1]] - finalPlume[ind_OPT[i+1]] ) ), 2);
                }

                if ( METRIC < METRIC_min ) {
                    METRIC_min = METRIC;
                    imin = j;
                }

                if ( METRIC < METRIC_ABS_MIN ) {
                    METRIC_ABS_MIN = METRIC;
                    for ( i = 0; i < NOPT; i++ ) {
                        VAR_OPT[ind_OPT[i]] = VAR_INIT[ind_OPT[i]];
                        VAR_OPT[ind_HNO3]   = VAR_INIT[ind_HNO3];
                    }
                }
            }

            /* ---- LINE SEARCH ENDS HERE ----------- */

            alpha_step = alpha_maxstep/STEPARRAY[imin];
            if ( verbose )
                printf("\nBest step: %d, step: %f\n\n",imin,alpha_step);

            for ( i = 0; i < NVAR; i++ )
                VAR_MOD[i] = VAR_DIR[i];
            for ( i = 0; i < NOPT; i++ ) {
                VAR_MOD[ind_OPT[i]]  = VAR_DIR[ind_OPT[i]] + alpha_step * dir[i] / DIAG[i];
                VAR_INIT[ind_OPT[i]] = VAR_MOD[ind_OPT[i]];
            }
            VAR_MOD[ind_HNO3] -= alpha_step * ( dir[0] / DIAG[0] + dir[1] / DIAG[1] );
            VAR_INIT[ind_HNO3] = VAR_MOD[ind_HNO3];

            /* Adjoint computation */
            ICNTRL[6] = 2;

            /* ---- INITIALIZE SENSITIVITIES ---------- */

            for( i = 0; i < NADJ; i++ ) {
                for( j = 0; j < NVAR; j++ )
                    Y_adj[i][j] = (double)0.0;
            }
            for( j = 0; j < NADJ; j++ )
                Y_adj[j][j] = (double)1.0;

            /* ---- INITIALIZE RATES ------------------ */

            for ( i = 0; i < NREACT; i++ )
                RCONST[i] = 0.0E+00;

            for ( i = 0; i < NSPEC; i++ ) {
                HET[i][0] = 0.0E+00;
                HET[i][1] = 0.0E+00;
                HET[i][2] = 0.0E+00;
            }

            Update_RCONST( temperature_K, pressure_Pa, airDens, VAR_MOD[ind_H2O] );

            /* ---- COMPUTE SENSITIVITIES -------------- */

            TIME = TSTART;
            IERR = INTEGRATE_ADJ( NADJ, VAR_MOD, Y_adj, TSTART, TEND, ATOL_adj, RTOL_adj, ICNTRL, RCNTRL, ISTATUS, RSTATUS );

            if ( IERR < 0 ) {
                return IERR;
            }

            METRIC = 0.0;
            for ( i = 0; i < NOPT - 1; i++ ) {
                if ( i < 1 ) { //NOx
                    METRIC_i[i] = pow( ( WEIGHTS[ind_OPT[0]] * DIAG[0] * ( VAR_MOD[ind_OPT[0]] + VAR_MOD[ind_OPT[1]] - finalPlume[ind_OPT[0]] - finalPlume[ind_OPT[1]] ) ), 2);
                    METRIC += METRIC_i[i];
                }
                else {
                    METRIC_i[i] = pow( ( WEIGHTS[ind_OPT[i+1]] * DIAG[i+1] * ( VAR_MOD[ind_OPT[i+1]] - finalPlume[ind_OPT[i+1]] ) ), 2);
                    METRIC += METRIC_i[i];
                }
            }

            if ( verbose ) {
                printf("\nMETRIC: %6.5e\n\n",METRIC);

                printf("%15s,  %5s,  %5s, %6s, %6s, %5s\n","SPECIES","C=0","INIT","OUTPUT","PLUME","AMBIENT");
                printf("%15s, %2.3f, %2.3f, %2.3f, %2.3f, %2.3f, %2.3f\n","NOx", (VAR[ind_OPT[0]]+VAR[ind_OPT[1]])/airDens*TOPPT, \
                       (VAR_DIR[ind_OPT[0]]+VAR_DIR[ind_OPT[1]] + alpha_step * (dir[0]/DIAG[0] + dir[1]/DIAG[1]))/airDens*TOPPT, \
                       (VAR_MOD[ind_OPT[0]]+VAR_MOD[ind_OPT[1]])/airDens*TOPPT, \
                       (finalPlume[ind_OPT[0]]+finalPlume[ind_OPT[1]])/airDens*TOPPT, \
                       (VAR_BACKG[ind_OPT[0]]+VAR_BACKG[ind_OPT[1]])/airDens*TOPPT, \
                       pow( (( VAR_MOD[ind_OPT[0]] + VAR_MOD[ind_OPT[1]] - finalPlume[ind_OPT[0]] - finalPlume[ind_OPT[1]] ) * DIAG[0] * WEIGHTS[ind_OPT[0]]), 2)/METRIC_min);
                printf("%15s, %2.2f, %2.2f, %2.2f, %2.2f, %2.2f\n","NOy", (VAR[ind_OPT[0]]+VAR[ind_OPT[1]]+VAR[ind_HNO3])/airDens*TOPPT, \
                       (VAR_DIR[ind_OPT[0]]+VAR_DIR[ind_OPT[1]]+VAR_DIR[ind_HNO3])/airDens*TOPPT, \
                       (VAR_MOD[ind_OPT[0]]+VAR_MOD[ind_OPT[1]]+VAR_MOD[ind_HNO3])/airDens*TOPPT, \
                       (finalPlume[ind_OPT[0]]+finalPlume[ind_OPT[1]]+finalPlume[ind_HNO3])/airDens*TOPPT, \
                       (VAR_BACKG[ind_OPT[0]]+VAR_BACKG[ind_OPT[1]]+VAR_BACKG[ind_HNO3])/airDens*TOPPT);
                for ( i = 2; i < NOPT; i++ )
                    printf("%15s, %2.3f, %2.3f, %2.3f, %2.3f, %2.3f, %2.3f\n",SPC_NAMES[ind_OPT[i]], VAR[ind_OPT[i]]/airDens*TOPPB, \
                       (VAR_DIR[ind_OPT[i]] + alpha_step*dir[i]/DIAG[i])/airDens*TOPPB, \
                       VAR_MOD[ind_OPT[i]]/airDens*TOPPB, finalPlume[ind_OPT[i]]/airDens*TOPPB, \
                       VAR_BACKG[ind_OPT[i]]/airDens*TOPPB, \
                       pow( (( VAR_MOD[ind_OPT[i]] - finalPlume[ind_OPT[i]] ) * DIAG[i] * WEIGHTS[ind_OPT[i]]), 2)/METRIC_min);
                printf("\n");
            }

            for ( i = 0; i < NVAR; i++ )
                VAR_DIR[i] = VAR_INIT[i];

            // if O3 delta smaller than 0.005 ppb and NOx delta smaller than 0.01 ppt
            if ( ABS((VAR_MOD[ind_O3] - finalPlume[ind_O3])/airDens*TOPPB) < 0.005 && ABS((VAR_MOD[ind_NO] + VAR_MOD[ind_NO2] - finalPlume[ind_NO] - finalPlume[ind_NO2])/airDens*TOPPT) < 0.05 ) {
                if ( verbose )
                    printf(" Minimizer has been found!\n");
                break;
            }

//            norm_METRIC = 0.0;
//            for ( i = 0; i < 2; i++ ) {
//                printf("METRIC[%d]: %6.5e\n", i, METRIC_i[i]);
//                norm_METRIC += METRIC_i[i];
//            }

//            for ( i = 0; i < NVAR; i++ )
//                VAR_DIR[i] = VAR_INIT[i];

            /* Assigning new data */
            for ( i = 0; i < NOPT; i++ ) {
                for ( j = 0; j < NOPT; j++ )
                    A_mat[i][j] = (double) Y_adj[ind_OPT[j]][ind_OPT[i]];
                wDiff[i] = WEIGHTS[ind_OPT[i]] * DIAG[i] * ( VAR_MOD[ind_OPT[i]] - finalPlume[ind_OPT[i]] );// / abs(( VAR_BACKG[ind_OPT[i]] - finalPlume[ind_OPT[i]] ));
            }
        
            /* Print reduced sensitivity matrix and weighted difference
             * to console? */
            if ( verbose ) {
                printf(" Printing reduced sensitivity matrix\n");
                printf(" J^T = [");
                for ( i = 0; i < NOPT; i++ ) {
                    if ( i > 0 )
                        printf("      [");
                    for ( j = 0; j < NOPT; j++ )
                        printf("%.3e ",A_mat[i][j]);
                    printf("]\n");
                }
                printf(" Weighted difference\n");
                printf(" wDiff = [");
                for ( i = 0; i < NOPT; i++ )
                    printf("%.3e ",wDiff[i]);
                printf("]\n");
            }

            /* ---- COMPUTE NEW DIRECTION ----------------- */

            /* Compute the new direction */
            for ( i = 0; i < NOPT; i++ ) {
                dirold[i] = dir[i];
                dir[i] = 0.0E+00;
                for ( j = 0; j < NOPT; j++ )
                    dir[i] -= A_mat[i][j] * wDiff[j];
            }
            
            /* Update the CG parameter */
            beta = 0.0E+00;
            /* Only select ONE of the following update formula!! */
            for ( i = 0; i < NOPT; i++ ) {
                /* Fletcher-Reeves */
                beta += dir[i] * dir[i] / ( dirold[i] * dirold[i] );
                /* Polak-RibiÃ¨re */
                beta += dir[i] * ( dir[i] - dirold[i] ) / ( dirold[i] * dirold[i] );
                beta = MAX( 0, beta );
                /* Hestenes-Stiefel */
                /* ... */
            }

            if ( verbose ) {
                printf("O3: %2.7f, %2.7f\n",VAR_MOD[ind_O3]/airDens*1E9, finalPlume[ind_O3]/airDens*1E9);
                printf("NOx: %2.7f, %2.7f\n",(VAR_MOD[ind_NO]+VAR_MOD[ind_NO2])/airDens*1E12, (finalPlume[ind_NO] + finalPlume[ind_NO2])/airDens*1E12);
            }

            /* Computing step */
            alpha_maxstep = -1.0;
            for ( i = 0; i < NOPT; i++ ) {
                if (VAR_DIR[i]/dir[i] < 0)
                    alpha[i] = -(VAR_DIR[ind_OPT[i]] * DIAG[i])/dir[i];
                else
                    alpha[i] =  (VAR_DIR[ind_OPT[i]] * DIAG[i])/dir[i];
                if ( alpha_maxstep < 0.0 && alpha[i] > 0.0 )
                    alpha_maxstep = alpha[i];
                if ( alpha_maxstep > alpha[i] )
                    alpha_maxstep = alpha[i];
            }

            N++;

        }

        /* ---- OPTIMIZATION ENDS HERE ---------------------- */

        if ( verbose ) {
            for ( i = 0; i < NOPT - 1; i++ ) {
                if ( i < 1 )
                    printf("\n\n%4s, %6.4f, %6.4f, %6.4f\n","NOx",(VAR_DIR[ind_OPT[0]]+VAR_DIR[ind_OPT[1]])/airDens*TOPPT,\
                                                                  (VAR_MOD[ind_OPT[0]]+VAR_MOD[ind_OPT[1]])/airDens*TOPPT, \
                                                                  (finalPlume[ind_OPT[0]]+finalPlume[ind_OPT[1]])/airDens*TOPPT);
                else
                    printf("%4s, %6.4f, %6.4f, %6.4f\n",SPC_NAMES[ind_OPT[i+1]],(VAR_DIR[ind_OPT[i+1]])/airDens*TOPPB,\
                                                        (VAR_MOD[ind_OPT[i+1]])/airDens*TOPPB, \
                                                        (finalPlume[ind_OPT[i+1]])/airDens*TOPPB);
            }
            printf("\n");
        }

        unsigned int iNT = 0;
        double VAR_BOX[NVAR];

        for ( i = 0; i < NVAR; i++ ) {
//            VAR_BOX[i] = VAR_INIT[i];
            VAR_BOX[i] = VAR_OPT[i];
            VAR_OUTPUT[iNT * NVAR + i] = VAR_BOX[i];
        }

        ICNTRL[6] = 1; // No adjoint

        /* ---- TIME LOOP BEGINS HERE --------------- */

        for ( iNT = 0; iNT < NT - 1; iNT++ ) {
    
            for ( i = 0; i < NREACT; i++ )
                RCONST[i] = 0.0E+00;

            for ( i = 0; i < NSPEC; i++ ) {
                HET[i][0] = 0.0E+00;
                HET[i][1] = 0.0E+00;
                HET[i][2] = 0.0E+00;
            }

            Update_RCONST( temperature_K, pressure_Pa, airDens, VAR_BOX[ind_H2O] );

            IERR = INTEGRATE_ADJ( NADJ, VAR_BOX, Y_adj, timeArray[iNT], timeArray[iNT+1] , ATOL_adj, RTOL_adj, ICNTRL, RCNTRL, ISTATUS, RSTATUS );

            if ( IERR < 0 ) {
                return IERR;
            }

            for ( i = 0; i < NVAR; i++ )
                VAR_OUTPUT[(iNT + 1) * NVAR + i] = VAR_BOX[i];

        }
        
        /* ---- TIME LOOP ENDS HERE ----------------- */

  }

    return IERR;

}

/* End of MAIN_ADJ function                                          */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

